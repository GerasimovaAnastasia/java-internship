##  Концепции K8s (Pod, Deployment, Service)
**Pod** - это один и единственный объект в Kubernetes, который приводит к запуску контейнеров.
Pod определяется представлением запроса на запуск (execute) одного или более контейнеров на одном узле, и эти контейнеры разделяют доступ 
к таким ресурсам, как тома хранилища и сетевой стек.

Однако в обиходе термин «pod» может употребляться и в смысле этого запроса, и в смысле 
совокупности контейнеров, которые запускаются в ответ на запрос. Pod'ы считаются базовыми строительными 
блоками Kubernetes, потому что все рабочие нагрузки в Kubernetes — например, Deployments, ReplicaSets и Jobs —
могут быть выражены в виде pod'ов.

**Deployment** - это ключевой компонент, широко используемый для управления контейнеризированными приложениями. 
Это одновременно API-объект и декларативный способ управления, масштабирования и обновления
контейнеризированных приложений. Deployment описывает желаемое состояние кластера Kubernetes и 
состояние запускаемых приложений — например, количество реплик, образ контейнера и прочие конфигурации, в то время как 
Kubernetes стремится поддерживать это состояние, автоматически занимаясь процессами обновления и масштабирования. 

В основе Deployment лежит управление набором идентичных подов (pods). Поды в Kubernetes — это 
минимальная единица («строительный блок»), в которой могут быть запущены один или несколько 
контейнеров. Контроллер Deployment, входящий в состав управляющей плоскости Kubernetes, 
гарантирует, что фактическое состояние соответствует желаемому, указанному в манифесте формата 
YAML. Также Deployment используется с другими функциями Kubernetes, такими как сервисы, Ingress 
и горизонтальное автомасштабирование подов.

**Service** - это объект, который используется для определения логических групп подов и правил 
доступа к ним. Поды в Kubernetes имеют временный (эфирный) характер: их можно создавать, удалять, перезапускать
или перемещать между узлами кластера. Это делает прямой доступ к подам по их IP-адресам ненадежным. Сервисы 
решают эту проблему, предоставляя стабильный сетевой интерфейс для взаимодействия с подами. Каждый сервис получает 
виртуальный IP-адрес (ClusterIP) или DNS-имя, через которые можно обращаться к группе подов, даже если сами поды меняются. 

Сервисы в Kubernetes классифицируются на несколько видов, каждый из которых разработан для конкретных задач и сценариев применения. Всего в Kubernetes присутствует пять типов сервисов:

- **ClusterIP**  
  Тип сервиса, который используется в Kubernetes по умолчанию. Сервис создает виртуальный IP-адрес внутри кластера, который используется для доступа к подам, 
соответствующим селектору сервиса.
- **NodePort**  
  Сервис типа NodePort открывает доступ к подам через порт на каждом узле кластера.
- **LoadBalancer**  
  Обеспечивает доступ к приложениям в кластере через балансировщик нагрузки, созданный в 
облачной инфраструктуре. Этот тип сервиса автоматически присваивает внешний IP-адрес для 
доступа пользователей к приложению. LoadBalancer можно использовать для production-приложений, где важны высокая доступность и масштабируемость.
- **ExternalName**  
  Тип сервиса, который используется для создания ссылки на внешний ресурс, 
находящийся за пределами кластера Kubernetes, без необходимости создания локального прокси.
Это позволяет направлять трафик к внешнему сервису, используя DNS-имя, без выделения ClusterIP или создания подов в кластере.
- **Headless Service**  
  Тип сервиса, который не привязан к ClusterIP. Он обеспечивает DNS-записи для 
всех подов, соответствующих указанному селектору. Такой сервис применяется для прямого взаимодействия с каждым подом, например, в распределенных системах, таких как базы данных или системы обработки сообщений.

**ConfigMap** — объект API Kubernetes, предназначенный для хранения некритичной, неконфиденциальной конфигурации 
(например, файлы свойств, переменные среды, командные аргументы) в виде пар "ключ-значение" или целых
конфигурационных файлов. Основная цель — отделение конфигурации от образов контейнеров для обеспечения переносимости и
гибкости приложений. Конфигурационные данные из ConfigMap могут быть подключены к подам двумя основными способами: в 
виде переменных среды внутри контейнеров или в виде файлов в смонтированном томе. Это позволяет динамически менять настройки 
приложения без необходимости пересборки его образа.

**Secret** — объект для безопасного хранения конфиденциальных данных (пароли, токены, ключи) в закодированном виде, 
которые могут быть предоставлены контейнерам в подах. Для повышения безопасности рекомендуется использовать шифрование 
секретов на уровне хранилища (etcd). Секреты могут быть предоставлены контейнерам в подах аналогично
ConfigMap: в виде переменных среды (менее безопасно, так как могут быть видны в переменных процесса) или, что 
предпочтительнее, в виде файлов в смонтированном томе в памяти (tmpfs), что снижает риск их попадания на постоянное хранилище. 
Важно отметить, что Secret предназначен для хранения секретов, а не для полного управления ими; для работы с высокочувствительными данными
используются более специализированные системы (например, HashiCorp Vault, Azure Key Vault), интегрируемые с Kubernetes через механизмы вроде Secrets Store CSI Driver 
или External Secrets Operator.

